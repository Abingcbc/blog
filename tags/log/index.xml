<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Log | Abing's Blog</title><link>https://blog.abingcbc.cn/tags/log/</link><atom:link href="https://blog.abingcbc.cn/tags/log/index.xml" rel="self" type="application/rss+xml"/><description>Log</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>zh-cn</language><lastBuildDate>Fri, 27 Oct 2023 21:00:00 +0800</lastBuildDate><item><title>iLogtail Go 插件内存 GC 优化最佳实践</title><link>https://blog.abingcbc.cn/posts/ilogtail-go-gc/</link><pubDate>Fri, 27 Oct 2023 21:00:00 +0800</pubDate><guid>https://blog.abingcbc.cn/posts/ilogtail-go-gc/</guid><description>&lt;h2 id="背景介绍" class="relative group">背景介绍 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%83%8c%e6%99%af%e4%bb%8b%e7%bb%8d" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;p>iLogtail 是阿里云日志服务（SLS）团队自研的可观测数据采集 Agent，拥有的轻量级、高性能、自动化配置等诸多生产级别特性，可以署于物理机、虚拟机、Kubernetes 等多种环境中来采集遥测数据。目前 iLogtail 已有千万级的安装量，每天采集数十 PB 的可观测数据，广泛应用于线上监控、问题分析/定位、运营分析、安全分析等多种场景，在实战中验证了其强大的性能和稳定性。&lt;/p>
&lt;p>为了满足用户对于拓展性的需求，iLogtail 采用了 Go 编写插件系统。在日志采集的场景中，每一条日志都对应了插件系统中一个日志对象。这个对象的生命周期随着在读取日志时开始，在发送日志后结束。然而，再处理大量的日志时，频繁的对象创建和销毁会对 Go 垃圾回收的性能产生一定的要求。&lt;/p>
&lt;p>在这篇文章中，我们将会介绍 iLogtail 中与 Go GC 相关的参数，以及如何根据不同的使用场景对这些参数进行配置。通过深入了解这些参数，用户可以更好地优化 iLogtail 的性能，提高日志采集的效率和准确性。&lt;/p>
&lt;h2 id="go-垃圾回收" class="relative group">Go 垃圾回收 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#go-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;p>在了解 iLogtail 对 Go GC 的管理和优化之前，我们先简单介绍一下 Go 垃圾回收的相关背景知识。&lt;/p>
&lt;h3 id="gc-触发机制" class="relative group">GC 触发机制 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#gc-%e8%a7%a6%e5%8f%91%e6%9c%ba%e5%88%b6" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>Go 会在以下三种情况下触发垃圾回收：&lt;/p>
&lt;ol>
&lt;li>堆大小触发：堆内存的分配达到控制器计算的触发堆大小。触发堆大小的计算公式如下：&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>触发堆大小 = live heap + (live heap + GC roots) * GOGC / 100
&lt;/code>&lt;/pre>&lt;p>Live heap 是上次 GC 后堆内剩余活跃的对象大小，GC roots 是栈或者常量区中的对象大小，GOGC 是 Go 1.19 之前，关于垃圾回收唯一可配置的参数，默认为 100。&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>时间触发：如果一定时间内没有触发，就会触发新的循环，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。但这个参数并提供没有接口进行修改。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>手动触发：手动调用 runtime.GC。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="soft-memory-limit" class="relative group">Soft Memory Limit &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#soft-memory-limit" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>在 Go 1.19 中，除了 GOGC 之外，新引入了 Soft Memory Limit，GOMEMLIMIT 这一参数，用于解决 OOM（Out Of Memory）的问题。
首先，我们先来看一下 Go 1.19 之前存在的问题。&lt;/p>
&lt;img src="./1.png" style="width:100%;margin-left:auto;margin-right:auto;">
&lt;p>上图很清楚地展示了 OOM 问题发生的场景。从下向上看，蓝色虚线表示 live heap 大小。黑色实线表示触发堆大小。红色虚线表示物理内存大小。在1、2处各发生了一次 GC，从而导致触发堆的大小增长。然而，当第二次 GC 改变触发堆大小后，就超过了实际物理内存大小。但 Go 内存管理器没有感知到这一点，仍然在不断地分配内存。直到达到 hard memory limit，导致 OOM。而在此期间由于没有达到触发堆大小（时间短的情况下，也不会触发定时GC），不会触发GC。&lt;/p>
&lt;p>而 GOMEMLIMIT 的引入就相当于在上图中引入了绿色虚线。为 Go 的内存使用大小设置了一个上限，保证了 Go 的内存使用不会超过物理内存。&lt;/p>
&lt;p>（下图仅为示意，GOMEMLIMIT 限制的不仅仅是堆大小，而是整个 Go 所使用的内存容量）&lt;/p>
&lt;img src="./2.png" style="width:100%;margin-left:auto;margin-right:auto;">
&lt;h3 id="gc-cpu-占用控制" class="relative group">GC CPU 占用控制 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#gc-cpu-%e5%8d%a0%e7%94%a8%e6%8e%a7%e5%88%b6" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>在 Go 1.19 之前，存在着一个问题叫作死亡螺旋（death spirals）。GC 回收器会临时征用用户的工作 goroutine 来进行垃圾回收的工作。当堆越大，GC 需要扫描的空间也就越大，消耗的 CPU 时间也越大。用户工作 goroutine 的 CPU 时间就越少，堆内的对象就一直不会被处理完，无法释放。最终，GC 可能会持续一直的运行。&lt;/p>
&lt;p>为了避免死亡螺旋，Go 1.19 采用了 leaky bucket，对 GC 所能够使用的 CPU 时间进行限制。&lt;/p>
&lt;img src="./3.png" style="width:100%;margin-left:auto;margin-right:auto;">
&lt;p>算法实现了一个抽象的桶。当发生 GC 时，会向桶内增加 GC 所耗费的 CPU 时间。而当执行用户任务时，则会从桶中抽出时间。当桶内的水位达到一定阈值后，就会阻止 GC 征用用户 goroutine 来辅助 GC。该功能的作者将 GC 可使用的 CPU 时间占比（桶的水位）设置为了 50%。这避免了频繁 GC 导致的问题。但同时，由于 GC 次数会被强制降速（不能征用用户 goroutine 来辅助了），所以在快到达 soft memory limit 时，有可能稍微超出。&lt;/p>
&lt;h2 id="ilogtail-插件启动策略" class="relative group">iLogtail 插件启动策略 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#ilogtail-%e6%8f%92%e4%bb%b6%e5%90%af%e5%8a%a8%e7%ad%96%e7%95%a5" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;p>在 Go 1.19 前，为了更加精细地管理 Go 内存使用情况，iLogtail 对于启动或者重启时需要处理大量堆积的历史日志的场景，设计了特殊的内存管理策略，避免启动时对内存造成很大的压力。iLogtail 的插件系统启动策略可以概括为以下两个阶段：&lt;/p>
&lt;ol>
&lt;li>启动阶段：设置触发堆的增长大小 GOGC 为较小的值，更加频繁地触发 GC（避免内存激增、避免 OOM）&lt;/li>
&lt;li>正常阶段：启动一段时间后，恢复触发堆的增长大小为默认设置&lt;/li>
&lt;/ol>
&lt;img src="./4.png" style="width:100%;margin-left:auto;margin-right:auto;">
&lt;p>然而，这个方法并不是完美的，在 iLogtail 升级 Go 1.19 之前仍然存在着以下两个问题：&lt;/p>
&lt;ol>
&lt;li>在启动阶段，通过更频繁的 GC 只能尽可能地缓解插件系统的内存使用量，并不能 100% 保证不出现 OOM 的情况。&lt;/li>
&lt;li>在保证内存使用量（避免 OOM）的情况下，无法优化 GC 所占用的 CPU 时间。无论在启动或是正常运行阶段，如果为了通过减小 GC 触发堆的增长来避免 OOM，就很容易导致 GC 次数过于频繁，占用大量的 CPU 时间。&lt;/li>
&lt;/ol>
&lt;h2 id="升级方案" class="relative group">升级方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8d%87%e7%ba%a7%e6%96%b9%e6%a1%88" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;p>为了优化以上两个问题，iLogtail 从 1.6.0 版本开始，升级支持了 Go 1.19，并向用户提供了 4个与 Go GC 相关的参数，其中两个为 Go 环境变量，两个为 iLogtail 环境变量。&lt;/p>
&lt;h3 id="gogc" class="relative group">GOGC &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#gogc" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>GOGC 为 Go 原生的环境变量，也是在 Go 1.19 之前唯一可以对 Go GC 进行修改的参数。对于 iLogtail，该参数的作用是控制启动结束，策略更改后 GC 的触发堆增长大小。&lt;/p>
&lt;p>默认值为 100。&lt;/p>
&lt;h3 id="gomemlimit" class="relative group">GOMEMLIMIT &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#gomemlimit" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>GOMEMLIMIT 为 Go 原生的环境变量，在 Go 1.19 加入。对于 iLogtail，该参数的作用是控制 Go 所能使用的内存上限。&lt;/p>
&lt;p>默认值为无限制。&lt;/p>
&lt;h3 id="aliyun_logtail_golang_gc_percent" class="relative group">ALIYUN_LOGTAIL_GOLANG_GC_PERCENT &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#aliyun_logtail_golang_gc_percent" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>ALIYUN_LOGTAIL_GOLANG_GC_PERCENT 为 iLogtail 自身的环境变量。该参数的作用是控制 iLogtail 在启动初始阶段，策略更改前 GC 的触发堆增长大小。&lt;/p>
&lt;p>默认值为 20。&lt;/p>
&lt;h3 id="aliyun_logtail_golang_gc_percent_resume_sec" class="relative group">ALIYUN_LOGTAIL_GOLANG_GC_PERCENT_RESUME_SEC &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#aliyun_logtail_golang_gc_percent_resume_sec" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>ALIYUN_LOGTAIL_GOLANG_GC_PERCENT_RESUME_SEC 为 iLogtail 自身的环境变量。该参数的作用是控制 iLogtail 启动初始阶段的时间长度。&lt;/p>
&lt;p>默认为 5 分钟，单位为秒。&lt;/p>
&lt;h2 id="具体场景与方案建议" class="relative group">具体场景与方案建议 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%85%b7%e4%bd%93%e5%9c%ba%e6%99%af%e4%b8%8e%e6%96%b9%e6%a1%88%e5%bb%ba%e8%ae%ae" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;p>本章节结合了刚才所提到的现有启动策略中的两个问题，提出了如何通过配置以上的 4 个参数实现对 GC 优化。有些特殊的 iLogtail 使用场景没有办法统一处理，可以参考下文场景中的优化思路。&lt;/p>
&lt;h3 id="场景一启动时处理历史日志导致-oom" class="relative group">场景一：启动时处理历史日志导致 OOM &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%9c%ba%e6%99%af%e4%b8%80%e5%90%af%e5%8a%a8%e6%97%b6%e5%a4%84%e7%90%86%e5%8e%86%e5%8f%b2%e6%97%a5%e5%bf%97%e5%af%bc%e8%87%b4-oom" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;h4 id="问题描述" class="relative group">问题描述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>在 iLogtail 启动或者重启时，有可能需要处理大量累积的历史日志。iLogtail 的内存使用率会出现显著的升高，甚至超出物理内存大小，导致 OOM。&lt;/p>
&lt;h4 id="问题原因" class="relative group">问题原因 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e5%8e%9f%e5%9b%a0" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>一部分原因是因为短时间内处理大量的日志，Go 插件中创建了大量的对象，内存使用量升高。另一部分原因是 Go 的内存管理器无法感知物理内存的上限，会无限扩充可使用的堆的大小。&lt;/p>
&lt;h4 id="解决方案" class="relative group">解决方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>在这种场景下，配置 GOMEMLIMIT 即可解决。&lt;/p>
&lt;p>但 iLogtail 作为一个日志采集工具，往往与其他程序共享计算机资源，在很多场景下，用户可能比较难配置一个明确的内存使用上限。这种情况下，可以使用 iLogtail 现有的插件系统启动策略，设置 ALIYUN_LOGTAIL_GOLANG_GC_PERCENT 为较小的值。通过牺牲短时间内的 CPU 使用率，换取 iLogtail 的平滑启动。&lt;/p>
&lt;h3 id="场景二gc-占用-cpu-时间过多" class="relative group">场景二：GC 占用 CPU 时间过多 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%9c%ba%e6%99%af%e4%ba%8cgc-%e5%8d%a0%e7%94%a8-cpu-%e6%97%b6%e9%97%b4%e8%bf%87%e5%a4%9a" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;h4 id="问题描述-1" class="relative group">问题描述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-1" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>客户在使用 iLogtail 采集日志，向 Kafka 发送时，发现性能出现了比较严重的下降。通过 Go pprof 进行分析发现，Go GC （runtime.gcBgMarkWorker）占用了大量的CPU，阻塞了正常的日志处理。&lt;/p>
&lt;img src="./5.png" style="width:100%;margin-left:auto;margin-right:auto;">
&lt;h4 id="问题原因-1" class="relative group">问题原因 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e5%8e%9f%e5%9b%a0-1" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>在 iLogtail 中，每一条日志都对应了一个 Log 对象。这个对象的生命周期其实特别短，从 input 创建，到 processor，最终 flusher 发送后，这个对象就被释放了。&lt;/p>
&lt;p>对于 50,000 条日志每秒的日志处理来说，那么一秒钟就涉及到了 50,000 * 2 次的对象创建和释放。假设每个对象 1KB，那么每秒就需要申请并释放大概 50MB 内存。&lt;/p>
&lt;h4 id="解决方案-1" class="relative group">解决方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-1" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>在配置了 GOMEMLIMIT 的情况下，如果关闭了触发堆 GC，即 GOGC=off，就只会在内存到达 GOMEMLIMIT 时，才会触发 GC，就可以大大的减少 GC 的次数。&lt;/p>
&lt;p>所以，可以配置以下的优化方案：&lt;/p>
&lt;ul>
&lt;li>限制 GOMEMLIMIT
&lt;ul>
&lt;li>如果对于内存的使用量有一定要求，则同时配置 GOGC 为一个较大的值，例如 200、300。减少 GC 的触发频次。&lt;/li>
&lt;li>如果对于内存的使用量没有限制，则同时配置 GOGC 为 off&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="场景三日志中转服务" class="relative group">场景三：日志中转服务 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%9c%ba%e6%99%af%e4%b8%89%e6%97%a5%e5%bf%97%e4%b8%ad%e8%bd%ac%e6%9c%8d%e5%8a%a1" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;h4 id="问题描述-2" class="relative group">问题描述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0-2" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>用户使用 iLogtail 作为日志中转处理服务，从一个 Kafka 中读取日志，经过 iLogtail 简单处理后，发送到另一个 Kafka 中进行存储。在这个场景下，用户不需要处理历史累积的日志，更加需要 iLogtail 启动后可以更快的提供高性能的服务。&lt;/p>
&lt;img src="./6.png" style="width:100%;margin-left:auto;margin-right:auto;">
&lt;h4 id="问题原因-2" class="relative group">问题原因 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%97%ae%e9%a2%98%e5%8e%9f%e5%9b%a0-2" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>iLogtail 默认的启动策略导致插件系统在启动时，会牺牲一定的 CPU 时间来换取内存安全。所以，会导致其在 iLogtail 刚启动的一小段时间内无法发挥全部的性能，提供最高效的服务。&lt;/p>
&lt;h4 id="解决方案-2" class="relative group">解决方案 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88-2" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h4>
&lt;p>这种情况下，需要关闭 iLogtail 的默认启动策略。可以将 ALIYUN_LOGTAIL_GOLANG_GC_PERCENT_RESUME_SEC 配置为 0，即在一开始就立刻进入正常运行的 GC 处理策略。&lt;/p>
&lt;h3 id="gomemlimit-与-gogc-配置建议" class="relative group">GOMEMLIMIT 与 GOGC 配置建议 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#gomemlimit-%e4%b8%8e-gogc-%e9%85%8d%e7%bd%ae%e5%bb%ba%e8%ae%ae" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;ul>
&lt;li>在配置 GOMEMLIMIT 时，需要注意 iLogtail 自身的内存使用参数 memory_usage_up_limit。该参数同时限制了 C++ 程序和 Go 插件系统总体的内存使用量，默认为 2GB。如果使用量超出该限制，会导致 iLogtail 发生重启。因此，GOMEMLIMIT 的值应当低于 memory_usage_up_limit。&lt;/li>
&lt;li>配置 GOGC=off 但不设置 GOMEMLIMIT 会导致 Go 插件系统中只有定时 GC，不推荐进行这样的配置。&lt;/li>
&lt;li>GOMEMLIMIT 设置了 Go 插件系统可使用的内存上限。但需要注意的是，Go 并不保证所使用的内存一定低于该上限。在 GC 发生拥塞的情况下，有可能由于垃圾回收不及时，导致使用量稍微超出该上限。所以，推荐将 GOMEMLIMIT 设为 Go 可使用内存上限的 95% ~ 96%。&lt;/li>
&lt;li>当无法确定与 iLogtail 在相同环境下运行的其他程序的内存使用大小时，不推荐将 GOGC 设置为 off，因为会导致 iLogtail 插件占用大量无效内存却不释放。如果这种情况下出现 GC 频繁的问题，推荐将 GOGC 设置为一个较大的值。&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料" class="relative group">参考资料 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;ol>
&lt;li>&lt;a
href="https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md"
target="_blank" rel="noreferrer noopener"
>https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md&lt;/a>&lt;/li>
&lt;li>&lt;a
href="https://github.com/golang/go/issues/48409"
target="_blank" rel="noreferrer noopener"
>https://github.com/golang/go/issues/48409&lt;/a>&lt;/li>
&lt;li>&lt;a
href="https://netflixtechblog.medium.com"
target="_blank" rel="noreferrer noopener"
>https://netflixtechblog.medium.com&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>常见日志采集器多行日志处理能力对比</title><link>https://blog.abingcbc.cn/posts/multiline/</link><pubDate>Fri, 12 May 2023 21:00:00 +0800</pubDate><guid>https://blog.abingcbc.cn/posts/multiline/</guid><description>&lt;h2 id="功能对比" class="relative group">功能对比 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8a%9f%e8%83%bd%e5%af%b9%e6%af%94" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Filebeat&lt;/th>
&lt;th>Fluent Bit&lt;/th>
&lt;th>Vector&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>正则&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>多种方式处理非匹配行&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>多种方式聚合日志&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>匹配到pattern时自动flush&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>日志达到一定数量自动flush&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>最大行数&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>超时自动flush&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>日志之间插入换行&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内置模板&lt;/td>
&lt;td>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>聚合前解析结构&lt;/td>
&lt;td>&lt;/td>
&lt;td>Y&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>总结：&lt;/p>
&lt;ol>
&lt;li>从功能方面，Filebeat 所支持的功能最多，其次是 Fluent Bit。&lt;/li>
&lt;li>从配置方面，Filebeat 通过 &lt;code>negate&lt;/code> 和 &lt;code>match&lt;/code> 两个字段的排列组合简化了配置，但对于用户有一定理解成本。而 Fluent Bit 所提供的基于状态的配置比较清晰易懂，但会导致配置文件结构复杂。&lt;/li>
&lt;li>从实现方面，前三者都采用了维护一个 buffer 的形式。&lt;/li>
&lt;/ol>
&lt;h2 id="filebeat" class="relative group">Filebeat &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#filebeat" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;img src="./beats.png" style="width:50%;margin-left:auto;margin-right:auto;">
&lt;h3 id="文档" class="relative group">文档 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%96%87%e6%a1%a3" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>&lt;strong>链接：&lt;/strong> &lt;a
href="https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html"
target="_blank" rel="noreferrer noopener"
>https://www.elastic.co/guide/en/beats/filebeat/current/multiline-examples.html&lt;/a>&lt;/p>
&lt;p>&lt;strong>支持功能：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>多种方式聚合多行日志，例如，pattern，count，while_pattern&lt;/p>
&lt;/li>
&lt;li>
&lt;p>正则匹配&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多种方式处理非匹配行&lt;/p>
&lt;p>个人理解：negate 相当于是区分判断 event 的主体是&lt;code>匹配行&lt;/code>还是&lt;code>非匹配行&lt;/code>。match 相当于是控制多行日志中的其他行附着到哪个主体（前or后）上。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>
&lt;figure>
&lt;img class="mx-auto my-0 rounded-md" src="./Untitled.png" alt="Untitled" />
&lt;/figure>
&lt;/p>
&lt;ol>
&lt;li>匹配到指定 pattern 时进行 flush&lt;/li>
&lt;li>指定数量的日志聚合成一个 event&lt;/li>
&lt;li>一个event最大行数&lt;/li>
&lt;li>超时自动flush&lt;/li>
&lt;li>多个event之间换行&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>样例：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="nl">parsers&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">-&lt;/span> &lt;span class="nl">multiline&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">pattern&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">pattern&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="na">[[:space:]]&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">negate&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nl">match&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">after&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">以下的&lt;/span> &lt;span class="n">log&lt;/span> &lt;span class="err">会被解析成一条：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Exception&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="kr">thread&lt;/span> &lt;span class="s">&amp;#34;main&amp;#34;&lt;/span> &lt;span class="n">java&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">NullPointerException&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">at&lt;/span> &lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">myproject&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Book&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getTitle&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Book&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">java&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">at&lt;/span> &lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">myproject&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Author&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getBookTitles&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Author&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">java&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">25&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">at&lt;/span> &lt;span class="n">com&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">example&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">myproject&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Bootstrap&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Bootstrap&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">java&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>解释：&lt;/strong> 这里pattern匹配的是前面带有空格的行，因此，多行的开始&lt;code>Exception&lt;/code>属于不匹配行。由于 negate 为 false，所以作为 event 的主体。后续匹配的&lt;code>at&lt;/code>会聚合成一个事件。&lt;/p>
&lt;h3 id="实现" class="relative group">实现 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e7%8e%b0" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>链接：&lt;a
href="https://github.com/elastic/beats"
target="_blank" rel="noreferrer noopener"
>https://github.com/elastic/beats&lt;/a>&lt;/p>
&lt;p>
&lt;figure>
&lt;img class="mx-auto my-0 rounded-md" src="./Untitled%201.png" alt="Untitled" />
&lt;/figure>
&lt;/p>
&lt;p>Filebeat (libbeat) 在 reader 模块实现了 multiline 的功能。&lt;/p>
&lt;ol>
&lt;li>根据配置项，在创建 parser 时，创建了 multiline 的 parser（reader）。根据不同的聚合模式，这里就会创建不同的 reader。&lt;/li>
&lt;li>在处理日志时，会不断地调用 Next 方法。&lt;/li>
&lt;li>Next 方法中的 state 函数，会根据当前的匹配状态（是否匹配了第一行）执行不同的逻辑。&lt;/li>
&lt;li>如果没有 buffer 为空，则 readFirst 中会在 Message Buffer 中创建一个新的 Message。然后进入 readNext 逻辑。&lt;/li>
&lt;li>readNext 中会不断从 file 的 reader 中读取日志，并添加到 Message Buffer 中。直至两种情况下，flush 日志，并将 state 重置为 readFirst：
&lt;ol>
&lt;li>匹配到强制 flush 的 pattern&lt;/li>
&lt;li>根据 &lt;code>negate&lt;/code> 和 &lt;code>match&lt;/code> 无法匹配成一条 message&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="fluent-bit" class="relative group">Fluent Bit &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#fluent-bit" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;img src="./fluent.png" style="width:50%;margin-left:auto;margin-right:auto;">
&lt;h3 id="文档-1" class="relative group">文档 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%96%87%e6%a1%a3-1" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>链接：&lt;a
href="https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/multiline-parsing"
target="_blank" rel="noreferrer noopener"
>https://docs.fluentbit.io/manual/administration/configuring-fluent-bit/multiline-parsing&lt;/a>&lt;/p>
&lt;p>&lt;strong>支持功能：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>内置多种类型日志的多行解析：docker，cri，go，python 和 java&lt;/li>
&lt;li>正则匹配&lt;/li>
&lt;li>支持匹配前解析，将文本解析成结构体&lt;/li>
&lt;li>支持对结构体指定字段进行匹配&lt;/li>
&lt;li>超时自动flush&lt;/li>
&lt;/ol>
&lt;p>fluent bit 将多行匹配问题，建模成了一个状态机。每一条规则包含三个部分：&lt;/p>
&lt;ol>
&lt;li>state name：一个multiline log的开始状态（start_state），还是继续状态（cont）&lt;/li>
&lt;li>正则表达式&lt;/li>
&lt;li>next state：这个状态后可能是什么状态&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>样例：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code># fluent bit 配置
[SERVICE]
flush 1
log_level info
parsers_file parsers_multiline.conf # 指定了 multiline 的规则
[INPUT]
name tail
path test.log
read_from_head true
multiline.parser multiline-regex-test # 指定了 multiline 的 parser
[OUTPUT]
name stdout
match *
# multiline 的规则
[MULTILINE_PARSER]
name multiline-regex-test
type regex
flush_timeout 1000
#
# Regex rules for multiline parsing
# ---------------------------------
#
# configuration hints:
#
# - first state always has the name: start_state
# - every field in the rule must be inside double quotes
#
# rules | state name | regex pattern | next state
# ------|---------------|--------------------------------------------
rule &amp;#34;start_state&amp;#34; &amp;#34;/([a-zA-Z]+ \d+ \d+\:\d+\:\d+)(.*)/&amp;#34; &amp;#34;cont&amp;#34;
rule &amp;#34;cont&amp;#34; &amp;#34;/^\s+at.*/&amp;#34; &amp;#34;cont&amp;#34;
# 可以被解析的规则
Dec 14 06:41:08 Exception in thread &amp;#34;main&amp;#34; java.lang.RuntimeException: Something has gone wrong, aborting!
at com.myproject.module.MyProject.badMethod(MyProject.java:22)
at com.myproject.module.MyProject.oneMoreMethod(MyProject.java:18)
at com.myproject.module.MyProject.anotherMethod(MyProject.java:14)
at com.myproject.module.MyProject.someMethod(MyProject.java:10)
at com.myproject.module.MyProject.main(MyProject.java:6)
&lt;/code>&lt;/pre>&lt;p>&lt;strong>解释：&lt;/strong> start_state 是以时间格式的正则匹配的，匹配到后，进入第二条 rule（以at开头）。然后不断匹配，直到遇到某一行可以被 start_state 所匹配。&lt;/p>
&lt;h3 id="实现-1" class="relative group">实现 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e7%8e%b0-1" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>&lt;strong>链接：&lt;/strong>&lt;a
href="https://github.com/fluent/fluent-bit/tree/master/src/multiline"
target="_blank" rel="noreferrer noopener"
>https://github.com/fluent/fluent-bit/tree/master/src/multiline&lt;/a>&lt;/p>
&lt;p>
&lt;figure>
&lt;img class="mx-auto my-0 rounded-md" src="./Untitled%202.png" alt="Untitled" />
&lt;/figure>
&lt;/p>
&lt;p>Fluent bit 从 v1.8 开始，就开始在 core 中支持了 multiline。为了兼容之前版本，依然保留了以插件的形式支持。&lt;/p>
&lt;ol>
&lt;li>在初始化时，会自动将所有 built-in 的 parser 加入了 context 的 multiline_parsers 链表中。&lt;/li>
&lt;li>接下来，会根据用户的配置，创建用户自定义的 parser，同样加入到链表中。这里 fluent bit 还做了一点优化，会维护一个 lru_parser，优先尝试使用上次的 parser 进行解析，避免对 multiline_parsers 进行查找。&lt;/li>
&lt;li>经过一系列调用后，核心的处理逻辑位于函数 flb_ml_rule_process 中。&lt;/li>
&lt;li>首先，会使用 start_state 的 rule 进行匹配。如果成功，则后续不断使用 cont 的 rule 进行匹配，并将日志加入到 buf 中。&lt;/li>
&lt;li>在两种情况下，可能发生 flush，并回到 start_state 状态：
&lt;ol>
&lt;li>匹配的 rule 的后续状态为 start_state&lt;/li>
&lt;li>当前日志被 start_state 的 rule 匹配&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="vector" class="relative group">Vector &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#vector" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h2>
&lt;img src="./vector.png" style="width:50%;margin-left:auto;margin-right:auto;">
&lt;h3 id="文档-2" class="relative group">文档 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%96%87%e6%a1%a3-2" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>&lt;strong>链接：&lt;/strong>&lt;a
href="https://vector.dev/docs/reference/configuration/sources/file/#multiline"
target="_blank" rel="noreferrer noopener"
>https://vector.dev/docs/reference/configuration/sources/file/#multiline&lt;/a>&lt;/p>
&lt;p>Vector 将多行日志的处理理解成了一种聚合方式。&lt;/p>
&lt;p>&lt;strong>支持功能：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>正则匹配&lt;/li>
&lt;li>多种方式处理非匹配行&lt;/li>
&lt;li>超时自动flush&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>样例：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code># vector 配置
[sources.my_file_source]
type = &amp;#34;file&amp;#34;
[sources.my_file_source.multiline]
start_pattern = &amp;#34;^[^\\s]&amp;#34;
mode = &amp;#34;continue_through&amp;#34;
condition_pattern = &amp;#34;^[\\s]+from&amp;#34;
timeout_ms = 1000
# 可以被解析的日志
foobar.rb:6:in `/&amp;#39;: divided by 0 (ZeroDivisionError)
from foobar.rb:6:in `bar&amp;#39;
from foobar.rb:2:in `foo&amp;#39;
from foobar.rb:9:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>解释：任何非空白开头的日志会被当做一个event的开始。然后匹配到 from 后，会根据 mode: continue_through 继续匹配。&lt;/strong>&lt;/p>
&lt;h3 id="实现-2" class="relative group">实现 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e7%8e%b0-2" aria-label="锚点">#&lt;/a>&lt;/span>&lt;/h3>
&lt;p>&lt;strong>链接：&lt;/strong> &lt;a
href="https://github.com/vectordotdev/vector/blob/master/src/line_agg.rs"
target="_blank" rel="noreferrer noopener"
>https://github.com/vectordotdev/vector/blob/master/src/line_agg.rs&lt;/a>&lt;/p>
&lt;p>
&lt;figure>
&lt;img class="mx-auto my-0 rounded-md" src="./Untitled%203.png" alt="Untitled" />
&lt;/figure>
&lt;/p>
&lt;ol>
&lt;li>Vector 中的多行处理是通过 LineAgg 类实现。&lt;/li>
&lt;li>在处理日志时，会不断地调用其 poll_next 方法。该方法中，会不断地读取日志，并根据 inner 读取的结果进行不同的处理。&lt;/li>
&lt;li>如果是 pending 状态，即没有新的日志需要处理。则会从 self.timeouts (实现上是一个 delayQueue）中去 flush 过期的日志。&lt;/li>
&lt;li>如果是 ready 状态，则处理新的日志。如果当前 buffer 为空，则直接 insert。同时 insert 进 timeout。&lt;/li>
&lt;li>如果当前 buffer 不为空，则根据配置采用不同的规则进行处理（add_next_line 或者 flush）。&lt;/li>
&lt;/ol></description></item></channel></rss>