<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="google-site-verification" content="O8l6Gdlm_7wLcePiA_vmgbeJoEon6vWqVfNFEdF35Vk" />
    <meta name="baidu-site-verification" content="code-Mg16qTh6pa" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <title>Sealos is All You Need —— 3分钟部署 Kubernetes</title>
    <!-- 
        <title>Sealos is All You Need —— 3分钟部署 Kubernetes</title>
     -->
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
<link rel="stylesheet" href="/css/jquery.fancybox.min.css">

    <script async defer data-website-id="e0d038ef-ec21-43e8-8170-a40528b7f0f6" src="https://abingcbc.cn:5100/analysis.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <script type="text/javascript" src="/js/jquery.min.js"></script>
        <script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
        <script type="text/javascript" src="/js/wrapImage.js"></script>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Bingchang Chen</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            Sealos is All You Need —— 3分钟部署 Kubernetes
        </div>
        <div class="post-meta">
            2022-10-30
            &nbsp;&nbsp;
            <span id="busuanzi_container_page_pv">
                <i class="iconfont icon-eye" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>次
            </span>
        </div>
    

    <div class="post-md">
        <p><img src="/asset/sealos-ramp-up/f6ce5cbedc6aa338007cd4633935ad371086271c.png" alt="title.png" /></p>
<h2 id="sealos-是什么"><a class="markdownIt-Anchor" href="#sealos-是什么"></a> Sealos 是什么？</h2>
<p>Kubernetes（K8s）发展至今，已经成为了一个极其复杂的系统。而作为云原生的基石，涌现了一大批辅助工具，帮助用户快速搭建 k8s 集群。而其中，<a target="_blank" rel="noopener" href="https://github.com/labring/sealos">Sealos</a> 是做得最为极致的工具之一。接下来，让我们通过一个例子来看看 Sealos 的强大。</p>
<h2 id="如何使用"><a class="markdownIt-Anchor" href="#如何使用"></a> 如何使用</h2>
<p><img src="/asset/sealos-ramp-up/313c52bda7b27b5b64a479e488404bcef56b2669.png" alt="Frame 3.png" /></p>
<p>假设我们想要在 192.168.0.100，192.168.0.101 和 192.168.0.102 这三台机器上部署一主两从的 K8s 集群，那么使用 Sealos 的话，主要输入以下的命令：</p>
<pre class="highlight"><code class="">sudo sealos run labring/kubernetes:v1.24.0 labring/calico:v3.22.1 \
    --masters 192.168.0.100 \
    --nodes 192.168.0.101,192.168.0.102 \
    --passwd xxx
</code></pre>
<p>是的，Sealos 将一个复杂的 K8s 的集群部署简化成了短短一行命令，将部署体验拉到了极致。甚至不需要过多的文档解释，仅凭这一行命令就可以满足大多数普通的部署场景。</p>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>那么，如此强大的 Sealos 是如何运行的呢？除了刚才演示的 <code>run</code> 命令之外，Sealos 还提供了大量提升用户体验的命令，例如 <code>create</code> 创建镜像、<code>reset</code> 格式化集群等等。由于篇幅有限，本章节就以最核心的 <code>run</code> 命令为例，看看 Sealos 在背后替用户完成了哪些自动化的操作。（本文以 Sealos V4.1.0 代码为例）</p>
<h3 id="applier"><a class="markdownIt-Anchor" href="#applier"></a> Applier</h3>
<p>首先，Sealos 会创建一个 <code>Applier</code> 结构体，负责了部署集群的核心逻辑。<code>Applier</code> 采用了 k8s 的声明式的设计思想，用户声明一个期望的集群状态，而 <code>Applier</code> 负责将集群现在的状态转换成用户期望的状态。</p>
<pre class="highlight"><code class="go"><span class="hljs-keyword">type</span> Applier <span class="hljs-keyword">struct</span> &#123;
    ClusterDesired     *v2.Cluster <span class="hljs-comment">// 用户期望的集群状态</span>
    ClusterCurrent     *v2.Cluster <span class="hljs-comment">// 集群当前状态</span>
    ClusterFile        clusterfile.Interface <span class="hljs-comment">// 当前集群接口</span>
    Client             kubernetes.Client
    CurrentClusterInfo *version.Info
    RunNewImages       []<span class="hljs-type">string</span> <span class="hljs-comment">// run 命令新增的镜像名称</span>
&#125;
</code></pre>
<p><code>clusterfile.Interface</code> 是一个接口类型，Sealos 中通过 <code>ClusterFile</code> 实现了这一接口。因此，<code>Applier</code> 结构体中最重要的就是 <code>Cluster</code> 和 <code>ClusterFile</code> 这两个类型，它们定义了集群的状态和配置。接下来，我们展开介绍一下两者。</p>
<h4 id="cluster"><a class="markdownIt-Anchor" href="#cluster"></a> Cluster</h4>
<pre class="highlight"><code class="go"><span class="hljs-keyword">type</span> Cluster <span class="hljs-keyword">struct</span> &#123;
    metav1.TypeMeta   <span class="hljs-string">`json:&quot;,inline&quot;`</span>
    metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot;`</span>

    Spec   ClusterSpec   <span class="hljs-string">`json:&quot;spec,omitempty&quot;`</span>
    Status ClusterStatus <span class="hljs-string">`json:&quot;status,omitempty&quot;`</span>
&#125;
<span class="hljs-keyword">type</span> ClusterSpec <span class="hljs-keyword">struct</span> &#123;
    Image ImageList <span class="hljs-string">`json:&quot;image,omitempty&quot;`</span>
    SSH   SSH       <span class="hljs-string">`json:&quot;ssh&quot;`</span>
    Hosts []Host    <span class="hljs-string">`json:&quot;hosts,omitempty&quot;`</span>
    Env []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;env,omitempty&quot;`</span>
    Command []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;command,omitempty&quot;`</span>
&#125;
<span class="hljs-keyword">type</span> ClusterStatus <span class="hljs-keyword">struct</span> &#123;
    Phase      ClusterPhase       <span class="hljs-string">`json:&quot;phase,omitempty&quot;`</span>
    Mounts     []MountImage       <span class="hljs-string">`json:&quot;mounts,omitempty&quot;`</span>
    Conditions []ClusterCondition <span class="hljs-string">`json:&quot;conditions,omitempty&quot; `</span>
&#125;
</code></pre>
<p><code>Cluster</code> 的内容按照 K8s Resource 的格式进行了设计，这非常的 K8s 哈哈。在 <code>ClusterSpec</code> 中，定义了一系列用于部署 K8s 集群的参数，例如，镜像、SSH参数、节点等等。</p>
<p>而在 <code>ClusterStatus</code> 中，<code>Phase</code> 定义了当前集群的状态，<code>Mounts</code> 定义了集群使用的镜像，<code>Conditions</code> 保存了集群中所发生的一系列事件。</p>
<h4 id="clusterfile"><a class="markdownIt-Anchor" href="#clusterfile"></a> ClusterFile</h4>
<pre class="highlight"><code class="go"><span class="hljs-keyword">type</span> ClusterFile <span class="hljs-keyword">struct</span> &#123;
    path         <span class="hljs-type">string</span> <span class="hljs-comment">// 保存路径</span>
    customValues []<span class="hljs-type">string</span>
    customSets   []<span class="hljs-type">string</span>
    customEnvs   []<span class="hljs-type">string</span>
    Cluster      *v2.Cluster <span class="hljs-comment">// 集群状态</span>
    Configs      []v2.Config
    KubeConfig   *runtime.KubeadmConfig <span class="hljs-comment">// 集群配置</span>
&#125;
</code></pre>
<p><code>ClusterFile</code> 是真正被 <code>Applier</code> 操作的对象，以及持久化到文件中的内容。这里包含了所有集群的当前状态信息，同时还包含了 kubeconfig。这里的 kubeconfig 并不是我们平时操作 k8s 时所用的 config 文件，而是一系列用于搭建集群所需的配置项。在使用 <code>kubeadm</code> 时，这些配置项往往需要我们手动配置，而 Sealos 在这里会自动帮我们填写并应用于集群中。可以看出，<code>Cluster</code> 更像是 <code>ClusterFile</code> 的一个实例，记录了集群实时的状态。</p>
<h3 id="创建-applier"><a class="markdownIt-Anchor" href="#创建-applier"></a> 创建 Applier</h3>
<p>创建一个 <code>Applier</code> 会经过以下步骤：</p>
<ol>
<li>
<p>判断是否已经存在 <code>ClusterFile</code> ，如果存在，那么直接读取，构建出集群状态 <code>Cluster</code>。否则，初始化创建一个空的集群状态 <code>Cluster</code>。</p>
</li>
<li>
<p>根据用户本次的参数，更新集群状态 <code>Cluster</code> 中的 spec，此时，<code>Cluster</code> 即为目标的集群状态。</p>
</li>
<li>
<p>再次从文件中构建 <code>ClusterFile</code>，作为集群当前的状态和对象。</p>
</li>
<li>
<p>构建 <code>Applier</code> 结构体返回。</p>
</li>
</ol>
<h3 id="apply"><a class="markdownIt-Anchor" href="#apply"></a> Apply</h3>
<p>接下来，通过 <code>Applier.Apply()</code>，Sealos 开始正式的部署集群，使集群状态向目标靠近。首先，Sealos 会将当前集群的状态置为 <code>ClusterInProcess</code>。接下来，根据集群创建或是更新，分别进入两个分支。</p>
<h4 id="initcluster"><a class="markdownIt-Anchor" href="#initcluster"></a> initCluster</h4>
<p><code>initCluster</code> 负责从零开始创建一个集群。函数中会通过 <code>CreateProcessor</code> 去部署期望状态的集群。</p>
<pre class="highlight"><code class="go"><span class="hljs-keyword">type</span> CreateProcessor <span class="hljs-keyword">struct</span> &#123;
    ClusterFile     clusterfile.Interface <span class="hljs-comment">// 当前集群对象</span>
    ImageManager    types.ImageService <span class="hljs-comment">// 处理镜像</span>
    ClusterManager  types.ClusterService <span class="hljs-comment">// 管理 clusterfile</span>
    RegistryManager types.RegistryService <span class="hljs-comment">// 管理镜像 registry</span>
    Runtime         runtime.Interface <span class="hljs-comment">// kubeadm 对象</span>
    Guest           guest.Interface <span class="hljs-comment">// 基于 sealos 的应用对象</span>
&#125;
</code></pre>
<p><img src="/asset/sealos-ramp-up/c668a66b40dbc788695a9cbb8ec3f76a9897503a.png" alt="Slide 16_9 - 1.png" /></p>
<p><code>CreateProcessor.Execute</code> 接收期望的集群状态 <code>ClusterDesired</code>。接下来会执行一系列 pipeline，正式进入实际的集群部署过程中：</p>
<ol>
<li>
<p>Check：检查集群的 host</p>
</li>
<li>
<p>PreProcess：负责集群部署前的镜像预处理操作，在这里就会利用 <code>CreateProcessor</code> 中的各个 Manager。</p>
<ol>
<li>
<p>拉取镜像</p>
</li>
<li>
<p>检查镜像格式</p>
</li>
<li>
<p>使用 <code>buildah</code> 从 OCI 格式的镜像中创建 working container，并将容器挂载到 rootfs 上</p>
</li>
<li>
<p>将容器的 manifest 添加到集群状态中</p>
</li>
</ol>
</li>
<li>
<p>RunConfig：将集群状态中的 working container 导出成 yaml 格式的配置并持久化到宿主机的文件系统中</p>
</li>
<li>
<p>MountRootfs：将挂载的镜像内容按照类别，以 <code>rootfs</code>，<code>addons</code>，<code>app</code> 的顺序分发到每台机器上。</p>
<p>这里需要介绍一下 sealos 镜像的一般结构，以最基础的 k8s 镜像为例：</p>
<pre class="highlight"><code class="">labring/kubernetes
- etc // 配置项
- scripts // 脚本
    - init-containerd.sh
    - init-kube.sh
    - init-shim.sh
    - init-registry.sh
    - init.sh
- Kubefile // dockerfile 语法，定义了镜像的执行逻辑
</code></pre>
<p>K8s 作为整个集群的基础，虽然最终镜像内的目录结构与其他一致，但其构建过程稍微有所不同。在 CI <a target="_blank" rel="noopener" href="https://github.com/labring/cluster-image/blob/faca63809e7a3eae512100a1eb8f9b7384973175/.github/scripts/kubernetes.sh#L35">https://github.com/labring/cluster-image/blob/faca63809e7a3eae512100a1eb8f9b7384973175/.github/scripts/kubernetes.sh#L35</a> 中，我们可以看到，k8s 镜像其实是合并了 cluster-image 仓库下的多个文件夹，<code>containerd</code>，<code>rootfs</code> 和 <code>registry</code>。这些独立的文件夹中包含有安装对应组件的脚本。</p>
<p>Sealos 在挂载一个镜像后，会首先执行 <code>init.sh</code> 脚本。例如，以下是 k8s 镜像的脚本中，分别按顺序执行了 <code>init-containerd.sh</code> 安装 containerd，<code>init-shim.sh</code> 安装 image-cri-shim 和 <code>init-kube.sh</code> 安装 kubelet。</p>
<pre class="highlight"><code class="">source common.sh
REGISTRY_DOMAIN=$&#123;1:-sealos.hub&#125;
REGISTRY_PORT=$&#123;2:-5000&#125;

# Install containerd
chmod a+x init-containerd.sh
bash init-containerd.sh $&#123;REGISTRY_DOMAIN&#125; $&#123;REGISTRY_PORT&#125;

if [ $? != 0 ]; then
   error &quot;====init containerd failed!====&quot;
fi

chmod a+x init-shim.sh
bash init-shim.sh

if [ $? != 0 ]; then
   error &quot;====init image-cri-shim failed!====&quot;
fi

chmod a+x init-kube.sh
bash init-kube.sh

logger &quot;init containerd rootfs success&quot;
</code></pre>
<p>在 MountRootfs 这步中，只会执行 <code>rootfs</code> 和 <code>addons</code> 类型的 <code>init.sh</code> 脚本。这也很好理解，因为到目前为止，Sealos 仅仅在每台机器上安装成功了 kubelet，整个 k8s 集群还未可用。</p>
</li>
<li>
<p>Init：初始化 k8s 集群。在这步中，其实也是执行了一系列的子操作。</p>
<ol>
<li>
<p>Sealos 会从 <code>ClusterFile</code> 中加载 <code>kubeadm</code> 的配置，然后拷贝到 master0 上。</p>
</li>
<li>
<p>根据 master0 的 hostname 生成证书以及 k8s 配置文件，例如 <code>admin.conf</code>，<code>controller-manager.conf</code>，<code>scheduler.conf</code>，<code>kubelet.conf</code>。</p>
</li>
<li>
<p>Sealos 将这些配置以及 rootfs 中的静态文件（主要是一些 policy 的配置）拷贝到 master0 上。</p>
</li>
<li>
<p>Sealos 通过 link 的方式将 rootfs 中的 registry 链接到宿主机的目录上，然后执行脚本 <code>init-registry.sh</code>，启动 registry 守护进程。</p>
</li>
<li>
<p>最后也是最重要的，初始化 master0。首先，将 registry 的域名，api server的域名（IP 为 master0 的 IP）添加到 master0 宿主机上。然后，调用 <code>kubeadm init</code> 创建 k8s 集群。最后，将生成的管理员 kubeconfig 拷贝到 <code>.kube/config</code>。</p>
</li>
</ol>
</li>
<li>
<p>Join：使用 kubeadm 将其余 master 和 node 加入现有的集群，然后更新 <code>ClusterFile</code>。此时，整个 k8s 集群就已经搭建完毕了。</p>
</li>
<li>
<p>RunGuest: 运行所有类型为 <code>app</code> 的镜像的 CMD，安装所有应用。</p>
</li>
</ol>
<p>至此一个 k8s 集群以及基于这个集群的所有应用都被安装完毕。</p>
<h4 id="reconcilecluster"><a class="markdownIt-Anchor" href="#reconcilecluster"></a> reconcileCluster</h4>
<p>第二个分支是负责集群的更新，大部分内容与 <code>initCluster</code> 都比较类似。执行主要包含了以下几步：</p>
<ol>
<li>
<p>ConfirmOverrideApps: 确认是否覆盖已有的应用。</p>
</li>
<li>
<p>PreProcess, RunConfig, MountRootfs, RunGuest: 都与 <code>initCluster</code> 类似。</p>
</li>
<li>
<p>PostProcess: 执行一些安装后的操作，但目前似乎并没有进行任何操作。</p>
</li>
</ol>
<h2 id="不仅仅如此"><a class="markdownIt-Anchor" href="#不仅仅如此"></a> 不仅仅如此…</h2>
<p>经过上文的介绍，可以看到 Sealos 本质上也可以认为是一个强大的 k8s 安装脚本。但未来的 Sealos 不仅仅如此，基于 Sealos 所开发的 sealos cloud 将会成为一个以 k8s 为内核的云操作系统，为更多应用的云原生之路带来更多便利。</p>
<p><img src="/asset/sealos-ramp-up/1ef54cfebd1c76bc8ecfd9897f9f127107b6e555.png" alt="" /></p>

    </div>

    
        <div id="gitalk" style="width: 100%"></div>
    

</div>

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    if (document.getElementById("gitalk")) {
        if (!window.__gitalk) window.__gitalk = new Gitalk({
            owner: 'abingcbc',
            repo: 'blog-comments',
            clientID: '225e0f79fd64ca42f501',
            clientSecret: 'e89fabf7e34f6646cf659179f7cd7943da170ce4',
            admin: ['abingcbc'],
            id: location.pathname
        });
        Object.assign(__gitalk, {
            id: decodeURIComponent(location.pathname),
            title: document.title,
            link: location.href,
        });
        __gitalk.render('gitalk');
    }
</script>
                <div class="footer">
    <span>Copyright © 2022 Bingchang Chen</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
    <span id="busuanzi_container_site_pv">
        Total views:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;times<br>
    </span>
    <span id="busuanzi_container_site_uv">
        Total visitors:&nbsp;<span id="busuanzi_value_site_uv"></span>&nbsp;times
    </span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>

<script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>
<script>
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>